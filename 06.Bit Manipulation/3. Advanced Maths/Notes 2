Divide two numbers using bit maipulation :

1) 25/4, we can keep checking the q by doing q++ andd doing till 25/q !=0
2) Instead we divide the 25 first by the max power possible. i.e, 4*b, max 2th power for b
and then we subtract it, then so on

int q = 1;
while (a > (b << q))	q++;
ans += (1 << (q - 1));		// As the present q is excess, we do q-1
a -= (b << (q - 1));
______________________________________________________

Count number of bits to be flipped to convert A to B : Do XOR and count bits using n & (1-n)
Find the number that appears odd number of times : same
Power Set : same
XOR of numbers from range L to R : Write the seperate function and do it for f(L-1) XOR f(R)
Find the two numbers appearing odd number of times : same
_________________________________________________________

Print all prime factors :

i) i : 1 to n
ii) i*i : 1 to n
iii) i*i : 1 to n, and n = n/i and if (n!=1) add n
_________________________________________________________

All Divisors of a Number : Don't do n = n/i, simply add all the numbers to list from i : 1 to i*i : n
_________________________________________________________

Sieve of Eratosthenes : 
First aassume all the numbers as prime, then run for loop from 2 to root(n)
Make all the multiples as false and use this j = i * i; j <= n; j += i to mark
As anyways 2*i to i-1*i are already generated by some past number
TC: O(n log log n) and SC: O(n)
_________________________________________________________

Prime factorization using Sieve :

Simply add { if(n%i==0) n=n/i } for pushing it as prime number in the answer vector
At the end, don't forget if(n>1) v.push_back(n)  	// Only for power of 2 gives n=1 at the end
Here, we are decrementing the n value, while above we are computing the table values
TC: O(n log log n) and SC: O(n)
_________________________________________________________

Power (x,n) : Fast exponentiation

n can be negative too, so do 1/ans at the end if it is. Also this question is to be done in double
Bits of n are to be considered. If 1, res*x*x, else x*x and do n>>1
TC : O(logN)
